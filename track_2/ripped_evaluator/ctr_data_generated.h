// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_H_

#include "flatbuffers/flatbuffers.h"

#include "features_generated.h"

namespace NCatBoostFbs {

struct TModelCtrBase;

struct TModelCtr;

struct TCtrFeature;

struct TCtrValueTable;

inline const flatbuffers::TypeTable *TModelCtrBaseTypeTable();

inline const flatbuffers::TypeTable *TModelCtrTypeTable();

inline const flatbuffers::TypeTable *TCtrFeatureTypeTable();

inline const flatbuffers::TypeTable *TCtrValueTableTypeTable();

enum ECtrType {
  ECtrType_Borders = 0,
  ECtrType_Buckets = 1,
  ECtrType_BinarizedTargetMeanValue = 2,
  ECtrType_FloatTargetMeanValue = 3,
  ECtrType_Counter = 4,
  ECtrType_FeatureFreq = 5,
  ECtrType_MIN = ECtrType_Borders,
  ECtrType_MAX = ECtrType_FeatureFreq
};

inline const ECtrType (&EnumValuesECtrType())[6] {
  static const ECtrType values[] = {
    ECtrType_Borders,
    ECtrType_Buckets,
    ECtrType_BinarizedTargetMeanValue,
    ECtrType_FloatTargetMeanValue,
    ECtrType_Counter,
    ECtrType_FeatureFreq
  };
  return values;
}

inline const char * const *EnumNamesECtrType() {
  static const char * const names[] = {
    "Borders",
    "Buckets",
    "BinarizedTargetMeanValue",
    "FloatTargetMeanValue",
    "Counter",
    "FeatureFreq",
    nullptr
  };
  return names;
}

inline const char *EnumNameECtrType(ECtrType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesECtrType()[index];
}

struct TModelCtrBase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TModelCtrBaseTypeTable();
  }
  enum {
    VT_FEATURECOMBINATION = 4,
    VT_CTRTYPE = 6
  };
  const TFeatureCombination *FeatureCombination() const {
    return GetPointer<const TFeatureCombination *>(VT_FEATURECOMBINATION);
  }
  TFeatureCombination *mutable_FeatureCombination() {
    return GetPointer<TFeatureCombination *>(VT_FEATURECOMBINATION);
  }
  ECtrType CtrType() const {
    return static_cast<ECtrType>(GetField<int8_t>(VT_CTRTYPE, 0));
  }
  bool mutate_CtrType(ECtrType _CtrType) {
    return SetField<int8_t>(VT_CTRTYPE, static_cast<int8_t>(_CtrType), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FEATURECOMBINATION) &&
           verifier.VerifyTable(FeatureCombination()) &&
           VerifyField<int8_t>(verifier, VT_CTRTYPE) &&
           verifier.EndTable();
  }
};

struct TModelCtrBaseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_FeatureCombination(flatbuffers::Offset<TFeatureCombination> FeatureCombination) {
    fbb_.AddOffset(TModelCtrBase::VT_FEATURECOMBINATION, FeatureCombination);
  }
  void add_CtrType(ECtrType CtrType) {
    fbb_.AddElement<int8_t>(TModelCtrBase::VT_CTRTYPE, static_cast<int8_t>(CtrType), 0);
  }
  explicit TModelCtrBaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TModelCtrBaseBuilder &operator=(const TModelCtrBaseBuilder &);
  flatbuffers::Offset<TModelCtrBase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TModelCtrBase>(end);
    return o;
  }
};

inline flatbuffers::Offset<TModelCtrBase> CreateTModelCtrBase(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TFeatureCombination> FeatureCombination = 0,
    ECtrType CtrType = ECtrType_Borders) {
  TModelCtrBaseBuilder builder_(_fbb);
  builder_.add_FeatureCombination(FeatureCombination);
  builder_.add_CtrType(CtrType);
  return builder_.Finish();
}

struct TModelCtr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TModelCtrTypeTable();
  }
  enum {
    VT_BASE = 4,
    VT_TARGETBORDERIDX = 6,
    VT_PRIORNUM = 8,
    VT_PRIORDENOM = 10,
    VT_SHIFT = 12,
    VT_SCALE = 14
  };
  const TModelCtrBase *Base() const {
    return GetPointer<const TModelCtrBase *>(VT_BASE);
  }
  TModelCtrBase *mutable_Base() {
    return GetPointer<TModelCtrBase *>(VT_BASE);
  }
  int32_t TargetBorderIdx() const {
    return GetField<int32_t>(VT_TARGETBORDERIDX, 0);
  }
  bool mutate_TargetBorderIdx(int32_t _TargetBorderIdx) {
    return SetField<int32_t>(VT_TARGETBORDERIDX, _TargetBorderIdx, 0);
  }
  float PriorNum() const {
    return GetField<float>(VT_PRIORNUM, 0.0f);
  }
  bool mutate_PriorNum(float _PriorNum) {
    return SetField<float>(VT_PRIORNUM, _PriorNum, 0.0f);
  }
  float PriorDenom() const {
    return GetField<float>(VT_PRIORDENOM, 1.0f);
  }
  bool mutate_PriorDenom(float _PriorDenom) {
    return SetField<float>(VT_PRIORDENOM, _PriorDenom, 1.0f);
  }
  float Shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool mutate_Shift(float _Shift) {
    return SetField<float>(VT_SHIFT, _Shift, 0.0f);
  }
  float Scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  bool mutate_Scale(float _Scale) {
    return SetField<float>(VT_SCALE, _Scale, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASE) &&
           verifier.VerifyTable(Base()) &&
           VerifyField<int32_t>(verifier, VT_TARGETBORDERIDX) &&
           VerifyField<float>(verifier, VT_PRIORNUM) &&
           VerifyField<float>(verifier, VT_PRIORDENOM) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct TModelCtrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Base(flatbuffers::Offset<TModelCtrBase> Base) {
    fbb_.AddOffset(TModelCtr::VT_BASE, Base);
  }
  void add_TargetBorderIdx(int32_t TargetBorderIdx) {
    fbb_.AddElement<int32_t>(TModelCtr::VT_TARGETBORDERIDX, TargetBorderIdx, 0);
  }
  void add_PriorNum(float PriorNum) {
    fbb_.AddElement<float>(TModelCtr::VT_PRIORNUM, PriorNum, 0.0f);
  }
  void add_PriorDenom(float PriorDenom) {
    fbb_.AddElement<float>(TModelCtr::VT_PRIORDENOM, PriorDenom, 1.0f);
  }
  void add_Shift(float Shift) {
    fbb_.AddElement<float>(TModelCtr::VT_SHIFT, Shift, 0.0f);
  }
  void add_Scale(float Scale) {
    fbb_.AddElement<float>(TModelCtr::VT_SCALE, Scale, 1.0f);
  }
  explicit TModelCtrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TModelCtrBuilder &operator=(const TModelCtrBuilder &);
  flatbuffers::Offset<TModelCtr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TModelCtr>(end);
    return o;
  }
};

inline flatbuffers::Offset<TModelCtr> CreateTModelCtr(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TModelCtrBase> Base = 0,
    int32_t TargetBorderIdx = 0,
    float PriorNum = 0.0f,
    float PriorDenom = 1.0f,
    float Shift = 0.0f,
    float Scale = 1.0f) {
  TModelCtrBuilder builder_(_fbb);
  builder_.add_Scale(Scale);
  builder_.add_Shift(Shift);
  builder_.add_PriorDenom(PriorDenom);
  builder_.add_PriorNum(PriorNum);
  builder_.add_TargetBorderIdx(TargetBorderIdx);
  builder_.add_Base(Base);
  return builder_.Finish();
}

struct TCtrFeature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TCtrFeatureTypeTable();
  }
  enum {
    VT_CTR = 4,
    VT_BORDERS = 6
  };
  const TModelCtr *Ctr() const {
    return GetPointer<const TModelCtr *>(VT_CTR);
  }
  TModelCtr *mutable_Ctr() {
    return GetPointer<TModelCtr *>(VT_CTR);
  }
  const flatbuffers::Vector<float> *Borders() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  flatbuffers::Vector<float> *mutable_Borders() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CTR) &&
           verifier.VerifyTable(Ctr()) &&
           VerifyOffset(verifier, VT_BORDERS) &&
           verifier.VerifyVector(Borders()) &&
           verifier.EndTable();
  }
};

struct TCtrFeatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Ctr(flatbuffers::Offset<TModelCtr> Ctr) {
    fbb_.AddOffset(TCtrFeature::VT_CTR, Ctr);
  }
  void add_Borders(flatbuffers::Offset<flatbuffers::Vector<float>> Borders) {
    fbb_.AddOffset(TCtrFeature::VT_BORDERS, Borders);
  }
  explicit TCtrFeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TCtrFeatureBuilder &operator=(const TCtrFeatureBuilder &);
  flatbuffers::Offset<TCtrFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TCtrFeature>(end);
    return o;
  }
};

inline flatbuffers::Offset<TCtrFeature> CreateTCtrFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TModelCtr> Ctr = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> Borders = 0) {
  TCtrFeatureBuilder builder_(_fbb);
  builder_.add_Borders(Borders);
  builder_.add_Ctr(Ctr);
  return builder_.Finish();
}

inline flatbuffers::Offset<TCtrFeature> CreateTCtrFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TModelCtr> Ctr = 0,
    const std::vector<float> *Borders = nullptr) {
  return NCatBoostFbs::CreateTCtrFeature(
      _fbb,
      Ctr,
      Borders ? _fbb.CreateVector<float>(*Borders) : 0);
}

struct TCtrValueTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TCtrValueTableTypeTable();
  }
  enum {
    VT_MODELCTRBASE = 4,
    VT_INDEXHASHRAW = 6,
    VT_CTRBLOB = 8,
    VT_COUNTERDENOMINATOR = 10,
    VT_TARGETCLASSESCOUNT = 12
  };
  const TModelCtrBase *ModelCtrBase() const {
    return GetPointer<const TModelCtrBase *>(VT_MODELCTRBASE);
  }
  TModelCtrBase *mutable_ModelCtrBase() {
    return GetPointer<TModelCtrBase *>(VT_MODELCTRBASE);
  }
  const flatbuffers::Vector<uint8_t> *IndexHashRaw() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INDEXHASHRAW);
  }
  flatbuffers::Vector<uint8_t> *mutable_IndexHashRaw() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INDEXHASHRAW);
  }
  const flatbuffers::Vector<uint8_t> *CTRBlob() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CTRBLOB);
  }
  flatbuffers::Vector<uint8_t> *mutable_CTRBlob() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CTRBLOB);
  }
  int32_t CounterDenominator() const {
    return GetField<int32_t>(VT_COUNTERDENOMINATOR, 0);
  }
  bool mutate_CounterDenominator(int32_t _CounterDenominator) {
    return SetField<int32_t>(VT_COUNTERDENOMINATOR, _CounterDenominator, 0);
  }
  int32_t TargetClassesCount() const {
    return GetField<int32_t>(VT_TARGETCLASSESCOUNT, 0);
  }
  bool mutate_TargetClassesCount(int32_t _TargetClassesCount) {
    return SetField<int32_t>(VT_TARGETCLASSESCOUNT, _TargetClassesCount, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODELCTRBASE) &&
           verifier.VerifyTable(ModelCtrBase()) &&
           VerifyOffset(verifier, VT_INDEXHASHRAW) &&
           verifier.VerifyVector(IndexHashRaw()) &&
           VerifyOffset(verifier, VT_CTRBLOB) &&
           verifier.VerifyVector(CTRBlob()) &&
           VerifyField<int32_t>(verifier, VT_COUNTERDENOMINATOR) &&
           VerifyField<int32_t>(verifier, VT_TARGETCLASSESCOUNT) &&
           verifier.EndTable();
  }
};

struct TCtrValueTableBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ModelCtrBase(flatbuffers::Offset<TModelCtrBase> ModelCtrBase) {
    fbb_.AddOffset(TCtrValueTable::VT_MODELCTRBASE, ModelCtrBase);
  }
  void add_IndexHashRaw(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> IndexHashRaw) {
    fbb_.AddOffset(TCtrValueTable::VT_INDEXHASHRAW, IndexHashRaw);
  }
  void add_CTRBlob(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> CTRBlob) {
    fbb_.AddOffset(TCtrValueTable::VT_CTRBLOB, CTRBlob);
  }
  void add_CounterDenominator(int32_t CounterDenominator) {
    fbb_.AddElement<int32_t>(TCtrValueTable::VT_COUNTERDENOMINATOR, CounterDenominator, 0);
  }
  void add_TargetClassesCount(int32_t TargetClassesCount) {
    fbb_.AddElement<int32_t>(TCtrValueTable::VT_TARGETCLASSESCOUNT, TargetClassesCount, 0);
  }
  explicit TCtrValueTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TCtrValueTableBuilder &operator=(const TCtrValueTableBuilder &);
  flatbuffers::Offset<TCtrValueTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TCtrValueTable>(end);
    return o;
  }
};

inline flatbuffers::Offset<TCtrValueTable> CreateTCtrValueTable(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TModelCtrBase> ModelCtrBase = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> IndexHashRaw = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> CTRBlob = 0,
    int32_t CounterDenominator = 0,
    int32_t TargetClassesCount = 0) {
  TCtrValueTableBuilder builder_(_fbb);
  builder_.add_TargetClassesCount(TargetClassesCount);
  builder_.add_CounterDenominator(CounterDenominator);
  builder_.add_CTRBlob(CTRBlob);
  builder_.add_IndexHashRaw(IndexHashRaw);
  builder_.add_ModelCtrBase(ModelCtrBase);
  return builder_.Finish();
}

inline flatbuffers::Offset<TCtrValueTable> CreateTCtrValueTableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TModelCtrBase> ModelCtrBase = 0,
    const std::vector<uint8_t> *IndexHashRaw = nullptr,
    const std::vector<uint8_t> *CTRBlob = nullptr,
    int32_t CounterDenominator = 0,
    int32_t TargetClassesCount = 0) {
  return NCatBoostFbs::CreateTCtrValueTable(
      _fbb,
      ModelCtrBase,
      IndexHashRaw ? _fbb.CreateVector<uint8_t>(*IndexHashRaw) : 0,
      CTRBlob ? _fbb.CreateVector<uint8_t>(*CTRBlob) : 0,
      CounterDenominator,
      TargetClassesCount);
}

inline const flatbuffers::TypeTable *ECtrTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ECtrTypeTypeTable
  };
  static const char * const names[] = {
    "Borders",
    "Buckets",
    "BinarizedTargetMeanValue",
    "FloatTargetMeanValue",
    "Counter",
    "FeatureFreq"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TModelCtrBaseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TFeatureCombinationTypeTable,
    ECtrTypeTypeTable
  };
  static const char * const names[] = {
    "FeatureCombination",
    "CtrType"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TModelCtrTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TModelCtrBaseTypeTable
  };
  static const char * const names[] = {
    "Base",
    "TargetBorderIdx",
    "PriorNum",
    "PriorDenom",
    "Shift",
    "Scale"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TCtrFeatureTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_FLOAT, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TModelCtrTypeTable
  };
  static const char * const names[] = {
    "Ctr",
    "Borders"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TCtrValueTableTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TModelCtrBaseTypeTable
  };
  static const char * const names[] = {
    "ModelCtrBase",
    "IndexHashRaw",
    "CTRBlob",
    "CounterDenominator",
    "TargetClassesCount"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const NCatBoostFbs::TCtrValueTable *GetTCtrValueTable(const void *buf) {
  return flatbuffers::GetRoot<NCatBoostFbs::TCtrValueTable>(buf);
}

inline const NCatBoostFbs::TCtrValueTable *GetSizePrefixedTCtrValueTable(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<NCatBoostFbs::TCtrValueTable>(buf);
}

inline TCtrValueTable *GetMutableTCtrValueTable(void *buf) {
  return flatbuffers::GetMutableRoot<TCtrValueTable>(buf);
}

inline bool VerifyTCtrValueTableBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NCatBoostFbs::TCtrValueTable>(nullptr);
}

inline bool VerifySizePrefixedTCtrValueTableBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NCatBoostFbs::TCtrValueTable>(nullptr);
}

inline void FinishTCtrValueTableBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NCatBoostFbs::TCtrValueTable> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTCtrValueTableBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NCatBoostFbs::TCtrValueTable> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_CTRDATA_NCATBOOSTFBS_H_
