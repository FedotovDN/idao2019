// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_H_
#define FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_H_

#include "flatbuffers/flatbuffers.h"

namespace NCatBoostFbs {

struct TFloatFeature;

struct TCatFeature;

struct TOneHotFeature;

struct TFloatSplit;

struct TOneHotSplit;

struct TFeatureCombination;

inline const flatbuffers::TypeTable *TFloatFeatureTypeTable();

inline const flatbuffers::TypeTable *TCatFeatureTypeTable();

inline const flatbuffers::TypeTable *TOneHotFeatureTypeTable();

inline const flatbuffers::TypeTable *TFloatSplitTypeTable();

inline const flatbuffers::TypeTable *TOneHotSplitTypeTable();

inline const flatbuffers::TypeTable *TFeatureCombinationTypeTable();

enum ENanValueTreatment {
  ENanValueTreatment_AsIs = 0,
  ENanValueTreatment_AsFalse = 1,
  ENanValueTreatment_AsTrue = 2,
  ENanValueTreatment_MIN = ENanValueTreatment_AsIs,
  ENanValueTreatment_MAX = ENanValueTreatment_AsTrue
};

inline const ENanValueTreatment (&EnumValuesENanValueTreatment())[3] {
  static const ENanValueTreatment values[] = {
    ENanValueTreatment_AsIs,
    ENanValueTreatment_AsFalse,
    ENanValueTreatment_AsTrue
  };
  return values;
}

inline const char * const *EnumNamesENanValueTreatment() {
  static const char * const names[] = {
    "AsIs",
    "AsFalse",
    "AsTrue",
    nullptr
  };
  return names;
}

inline const char *EnumNameENanValueTreatment(ENanValueTreatment e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesENanValueTreatment()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TFloatSplit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Index_;
  float Border_;

 public:
  TFloatSplit() {
    memset(this, 0, sizeof(TFloatSplit));
  }
  TFloatSplit(int32_t _Index, float _Border)
      : Index_(flatbuffers::EndianScalar(_Index)),
        Border_(flatbuffers::EndianScalar(_Border)) {
  }
  int32_t Index() const {
    return flatbuffers::EndianScalar(Index_);
  }
  void mutate_Index(int32_t _Index) {
    flatbuffers::WriteScalar(&Index_, _Index);
  }
  float Border() const {
    return flatbuffers::EndianScalar(Border_);
  }
  void mutate_Border(float _Border) {
    flatbuffers::WriteScalar(&Border_, _Border);
  }
};
FLATBUFFERS_STRUCT_END(TFloatSplit, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TOneHotSplit FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Index_;
  int32_t Value_;

 public:
  TOneHotSplit() {
    memset(this, 0, sizeof(TOneHotSplit));
  }
  TOneHotSplit(int32_t _Index, int32_t _Value)
      : Index_(flatbuffers::EndianScalar(_Index)),
        Value_(flatbuffers::EndianScalar(_Value)) {
  }
  int32_t Index() const {
    return flatbuffers::EndianScalar(Index_);
  }
  void mutate_Index(int32_t _Index) {
    flatbuffers::WriteScalar(&Index_, _Index);
  }
  int32_t Value() const {
    return flatbuffers::EndianScalar(Value_);
  }
  void mutate_Value(int32_t _Value) {
    flatbuffers::WriteScalar(&Value_, _Value);
  }
};
FLATBUFFERS_STRUCT_END(TOneHotSplit, 8);

struct TFloatFeature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TFloatFeatureTypeTable();
  }
  enum {
    VT_HASNANS = 4,
    VT_INDEX = 6,
    VT_FLATINDEX = 8,
    VT_BORDERS = 10,
    VT_FEATUREID = 12,
    VT_NANVALUETREATMENT = 14
  };
  bool HasNans() const {
    return GetField<uint8_t>(VT_HASNANS, 0) != 0;
  }
  bool mutate_HasNans(bool _HasNans) {
    return SetField<uint8_t>(VT_HASNANS, static_cast<uint8_t>(_HasNans), 0);
  }
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  int32_t FlatIndex() const {
    return GetField<int32_t>(VT_FLATINDEX, -1);
  }
  bool mutate_FlatIndex(int32_t _FlatIndex) {
    return SetField<int32_t>(VT_FLATINDEX, _FlatIndex, -1);
  }
  const flatbuffers::Vector<float> *Borders() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  flatbuffers::Vector<float> *mutable_Borders() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_BORDERS);
  }
  const flatbuffers::String *FeatureId() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATUREID);
  }
  flatbuffers::String *mutable_FeatureId() {
    return GetPointer<flatbuffers::String *>(VT_FEATUREID);
  }
  ENanValueTreatment NanValueTreatment() const {
    return static_cast<ENanValueTreatment>(GetField<int8_t>(VT_NANVALUETREATMENT, 0));
  }
  bool mutate_NanValueTreatment(ENanValueTreatment _NanValueTreatment) {
    return SetField<int8_t>(VT_NANVALUETREATMENT, static_cast<int8_t>(_NanValueTreatment), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HASNANS) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_FLATINDEX) &&
           VerifyOffset(verifier, VT_BORDERS) &&
           verifier.VerifyVector(Borders()) &&
           VerifyOffset(verifier, VT_FEATUREID) &&
           verifier.VerifyString(FeatureId()) &&
           VerifyField<int8_t>(verifier, VT_NANVALUETREATMENT) &&
           verifier.EndTable();
  }
};

struct TFloatFeatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_HasNans(bool HasNans) {
    fbb_.AddElement<uint8_t>(TFloatFeature::VT_HASNANS, static_cast<uint8_t>(HasNans), 0);
  }
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TFloatFeature::VT_INDEX, Index, -1);
  }
  void add_FlatIndex(int32_t FlatIndex) {
    fbb_.AddElement<int32_t>(TFloatFeature::VT_FLATINDEX, FlatIndex, -1);
  }
  void add_Borders(flatbuffers::Offset<flatbuffers::Vector<float>> Borders) {
    fbb_.AddOffset(TFloatFeature::VT_BORDERS, Borders);
  }
  void add_FeatureId(flatbuffers::Offset<flatbuffers::String> FeatureId) {
    fbb_.AddOffset(TFloatFeature::VT_FEATUREID, FeatureId);
  }
  void add_NanValueTreatment(ENanValueTreatment NanValueTreatment) {
    fbb_.AddElement<int8_t>(TFloatFeature::VT_NANVALUETREATMENT, static_cast<int8_t>(NanValueTreatment), 0);
  }
  explicit TFloatFeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TFloatFeatureBuilder &operator=(const TFloatFeatureBuilder &);
  flatbuffers::Offset<TFloatFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TFloatFeature>(end);
    return o;
  }
};

inline flatbuffers::Offset<TFloatFeature> CreateTFloatFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool HasNans = false,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    flatbuffers::Offset<flatbuffers::Vector<float>> Borders = 0,
    flatbuffers::Offset<flatbuffers::String> FeatureId = 0,
    ENanValueTreatment NanValueTreatment = ENanValueTreatment_AsIs) {
  TFloatFeatureBuilder builder_(_fbb);
  builder_.add_FeatureId(FeatureId);
  builder_.add_Borders(Borders);
  builder_.add_FlatIndex(FlatIndex);
  builder_.add_Index(Index);
  builder_.add_NanValueTreatment(NanValueTreatment);
  builder_.add_HasNans(HasNans);
  return builder_.Finish();
}

inline flatbuffers::Offset<TFloatFeature> CreateTFloatFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool HasNans = false,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    const std::vector<float> *Borders = nullptr,
    const char *FeatureId = nullptr,
    ENanValueTreatment NanValueTreatment = ENanValueTreatment_AsIs) {
  return NCatBoostFbs::CreateTFloatFeature(
      _fbb,
      HasNans,
      Index,
      FlatIndex,
      Borders ? _fbb.CreateVector<float>(*Borders) : 0,
      FeatureId ? _fbb.CreateString(FeatureId) : 0,
      NanValueTreatment);
}

struct TCatFeature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TCatFeatureTypeTable();
  }
  enum {
    VT_INDEX = 4,
    VT_FLATINDEX = 6,
    VT_FEATUREID = 8,
    VT_USEDINMODEL = 10
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  int32_t FlatIndex() const {
    return GetField<int32_t>(VT_FLATINDEX, -1);
  }
  bool mutate_FlatIndex(int32_t _FlatIndex) {
    return SetField<int32_t>(VT_FLATINDEX, _FlatIndex, -1);
  }
  const flatbuffers::String *FeatureId() const {
    return GetPointer<const flatbuffers::String *>(VT_FEATUREID);
  }
  flatbuffers::String *mutable_FeatureId() {
    return GetPointer<flatbuffers::String *>(VT_FEATUREID);
  }
  bool UsedInModel() const {
    return GetField<uint8_t>(VT_USEDINMODEL, 1) != 0;
  }
  bool mutate_UsedInModel(bool _UsedInModel) {
    return SetField<uint8_t>(VT_USEDINMODEL, static_cast<uint8_t>(_UsedInModel), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_FLATINDEX) &&
           VerifyOffset(verifier, VT_FEATUREID) &&
           verifier.VerifyString(FeatureId()) &&
           VerifyField<uint8_t>(verifier, VT_USEDINMODEL) &&
           verifier.EndTable();
  }
};

struct TCatFeatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TCatFeature::VT_INDEX, Index, -1);
  }
  void add_FlatIndex(int32_t FlatIndex) {
    fbb_.AddElement<int32_t>(TCatFeature::VT_FLATINDEX, FlatIndex, -1);
  }
  void add_FeatureId(flatbuffers::Offset<flatbuffers::String> FeatureId) {
    fbb_.AddOffset(TCatFeature::VT_FEATUREID, FeatureId);
  }
  void add_UsedInModel(bool UsedInModel) {
    fbb_.AddElement<uint8_t>(TCatFeature::VT_USEDINMODEL, static_cast<uint8_t>(UsedInModel), 1);
  }
  explicit TCatFeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TCatFeatureBuilder &operator=(const TCatFeatureBuilder &);
  flatbuffers::Offset<TCatFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TCatFeature>(end);
    return o;
  }
};

inline flatbuffers::Offset<TCatFeature> CreateTCatFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    flatbuffers::Offset<flatbuffers::String> FeatureId = 0,
    bool UsedInModel = true) {
  TCatFeatureBuilder builder_(_fbb);
  builder_.add_FeatureId(FeatureId);
  builder_.add_FlatIndex(FlatIndex);
  builder_.add_Index(Index);
  builder_.add_UsedInModel(UsedInModel);
  return builder_.Finish();
}

inline flatbuffers::Offset<TCatFeature> CreateTCatFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    int32_t FlatIndex = -1,
    const char *FeatureId = nullptr,
    bool UsedInModel = true) {
  return NCatBoostFbs::CreateTCatFeature(
      _fbb,
      Index,
      FlatIndex,
      FeatureId ? _fbb.CreateString(FeatureId) : 0,
      UsedInModel);
}

struct TOneHotFeature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TOneHotFeatureTypeTable();
  }
  enum {
    VT_INDEX = 4,
    VT_VALUES = 6,
    VT_STRINGVALUES = 8
  };
  int32_t Index() const {
    return GetField<int32_t>(VT_INDEX, -1);
  }
  bool mutate_Index(int32_t _Index) {
    return SetField<int32_t>(VT_INDEX, _Index, -1);
  }
  const flatbuffers::Vector<int32_t> *Values() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  flatbuffers::Vector<int32_t> *mutable_Values() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_VALUES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *StringValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGVALUES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_StringValues() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRINGVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(Values()) &&
           VerifyOffset(verifier, VT_STRINGVALUES) &&
           verifier.VerifyVector(StringValues()) &&
           verifier.VerifyVectorOfStrings(StringValues()) &&
           verifier.EndTable();
  }
};

struct TOneHotFeatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(int32_t Index) {
    fbb_.AddElement<int32_t>(TOneHotFeature::VT_INDEX, Index, -1);
  }
  void add_Values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> Values) {
    fbb_.AddOffset(TOneHotFeature::VT_VALUES, Values);
  }
  void add_StringValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> StringValues) {
    fbb_.AddOffset(TOneHotFeature::VT_STRINGVALUES, StringValues);
  }
  explicit TOneHotFeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOneHotFeatureBuilder &operator=(const TOneHotFeatureBuilder &);
  flatbuffers::Offset<TOneHotFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOneHotFeature>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOneHotFeature> CreateTOneHotFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> Values = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> StringValues = 0) {
  TOneHotFeatureBuilder builder_(_fbb);
  builder_.add_StringValues(StringValues);
  builder_.add_Values(Values);
  builder_.add_Index(Index);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOneHotFeature> CreateTOneHotFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Index = -1,
    const std::vector<int32_t> *Values = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *StringValues = nullptr) {
  return NCatBoostFbs::CreateTOneHotFeature(
      _fbb,
      Index,
      Values ? _fbb.CreateVector<int32_t>(*Values) : 0,
      StringValues ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*StringValues) : 0);
}

struct TFeatureCombination FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TFeatureCombinationTypeTable();
  }
  enum {
    VT_CATFEATURES = 4,
    VT_FLOATSPLITS = 6,
    VT_ONEHOTSPLITS = 8
  };
  const flatbuffers::Vector<int32_t> *CatFeatures() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CATFEATURES);
  }
  flatbuffers::Vector<int32_t> *mutable_CatFeatures() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_CATFEATURES);
  }
  const flatbuffers::Vector<const TFloatSplit *> *FloatSplits() const {
    return GetPointer<const flatbuffers::Vector<const TFloatSplit *> *>(VT_FLOATSPLITS);
  }
  flatbuffers::Vector<const TFloatSplit *> *mutable_FloatSplits() {
    return GetPointer<flatbuffers::Vector<const TFloatSplit *> *>(VT_FLOATSPLITS);
  }
  const flatbuffers::Vector<const TOneHotSplit *> *OneHotSplits() const {
    return GetPointer<const flatbuffers::Vector<const TOneHotSplit *> *>(VT_ONEHOTSPLITS);
  }
  flatbuffers::Vector<const TOneHotSplit *> *mutable_OneHotSplits() {
    return GetPointer<flatbuffers::Vector<const TOneHotSplit *> *>(VT_ONEHOTSPLITS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CATFEATURES) &&
           verifier.VerifyVector(CatFeatures()) &&
           VerifyOffset(verifier, VT_FLOATSPLITS) &&
           verifier.VerifyVector(FloatSplits()) &&
           VerifyOffset(verifier, VT_ONEHOTSPLITS) &&
           verifier.VerifyVector(OneHotSplits()) &&
           verifier.EndTable();
  }
};

struct TFeatureCombinationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_CatFeatures(flatbuffers::Offset<flatbuffers::Vector<int32_t>> CatFeatures) {
    fbb_.AddOffset(TFeatureCombination::VT_CATFEATURES, CatFeatures);
  }
  void add_FloatSplits(flatbuffers::Offset<flatbuffers::Vector<const TFloatSplit *>> FloatSplits) {
    fbb_.AddOffset(TFeatureCombination::VT_FLOATSPLITS, FloatSplits);
  }
  void add_OneHotSplits(flatbuffers::Offset<flatbuffers::Vector<const TOneHotSplit *>> OneHotSplits) {
    fbb_.AddOffset(TFeatureCombination::VT_ONEHOTSPLITS, OneHotSplits);
  }
  explicit TFeatureCombinationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TFeatureCombinationBuilder &operator=(const TFeatureCombinationBuilder &);
  flatbuffers::Offset<TFeatureCombination> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TFeatureCombination>(end);
    return o;
  }
};

inline flatbuffers::Offset<TFeatureCombination> CreateTFeatureCombination(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> CatFeatures = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TFloatSplit *>> FloatSplits = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TOneHotSplit *>> OneHotSplits = 0) {
  TFeatureCombinationBuilder builder_(_fbb);
  builder_.add_OneHotSplits(OneHotSplits);
  builder_.add_FloatSplits(FloatSplits);
  builder_.add_CatFeatures(CatFeatures);
  return builder_.Finish();
}

inline flatbuffers::Offset<TFeatureCombination> CreateTFeatureCombinationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *CatFeatures = nullptr,
    const std::vector<TFloatSplit> *FloatSplits = nullptr,
    const std::vector<TOneHotSplit> *OneHotSplits = nullptr) {
  return NCatBoostFbs::CreateTFeatureCombination(
      _fbb,
      CatFeatures ? _fbb.CreateVector<int32_t>(*CatFeatures) : 0,
      FloatSplits ? _fbb.CreateVectorOfStructs<TFloatSplit>(*FloatSplits) : 0,
      OneHotSplits ? _fbb.CreateVectorOfStructs<TOneHotSplit>(*OneHotSplits) : 0);
}

inline const flatbuffers::TypeTable *ENanValueTreatmentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ENanValueTreatmentTypeTable
  };
  static const char * const names[] = {
    "AsIs",
    "AsFalse",
    "AsTrue"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TFloatFeatureTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ENanValueTreatmentTypeTable
  };
  static const char * const names[] = {
    "HasNans",
    "Index",
    "FlatIndex",
    "Borders",
    "FeatureId",
    "NanValueTreatment"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TCatFeatureTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const char * const names[] = {
    "Index",
    "FlatIndex",
    "FeatureId",
    "UsedInModel"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TOneHotFeatureTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 }
  };
  static const char * const names[] = {
    "Index",
    "Values",
    "StringValues"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TFloatSplitTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int32_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "Index",
    "Border"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TOneHotSplitTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const int32_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "Index",
    "Value"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_STRUCT, 2, type_codes, nullptr, values, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TFeatureCombinationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    TFloatSplitTypeTable,
    TOneHotSplitTypeTable
  };
  static const char * const names[] = {
    "CatFeatures",
    "FloatSplits",
    "OneHotSplits"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

}  // namespace NCatBoostFbs

#endif  // FLATBUFFERS_GENERATED_FEATURES_NCATBOOSTFBS_H_
